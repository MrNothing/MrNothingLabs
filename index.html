<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Terrain generator test</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #ffffff;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;

				background-color: #000000;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {

				color: #ffffff;
			}

			#oldie a { color:#da0 }
		</style>
	</head>
	<body>

		<button id="reset">Reset</button>
		<div id="container"></div>
		
		<script src="perlin.js"></script>
		<script src="build/three.min.js"></script>

		<script src="js/controls/FirstPersonControls.js"></script>

		<script src="js/shaders/ConvolutionShader.js"></script>
		<script src="js/shaders/CopyShader.js"></script>
		<script src="js/shaders/FilmShader.js"></script>

		<script src="js/postprocessing/EffectComposer.js"></script>
		<script src="js/postprocessing/ShaderPass.js"></script>
		<script src="js/postprocessing/MaskPass.js"></script>
		<script src="js/postprocessing/RenderPass.js"></script>
		<script src="js/postprocessing/BloomPass.js"></script>
		<script src="js/postprocessing/FilmPass.js"></script>

		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>

		<script id="fragmentShader" type="x-shader/x-fragment">
			#define range 0.05
			#define length 1.0

			uniform sampler2D texture1; //snow
			uniform sampler2D texture2; //grass
			uniform sampler2D texture3; //dirt
			uniform sampler2D texture4; //rocks
			uniform float time;

			varying vec2 vUv;
			varying vec3 vColor;
			varying float fogIntensity;
			varying float reflection;


			
			float rangeFactor(float t, float _point, float _range){
				return max(0.0, 1.0-(abs (_point - t) / _range));
			}

			float areaRangeFactor(float t, float _min, float _max, float _range){
				if(t>_min && t<_max)
					return 1.0;
				else
				{
					if(t<=_min)
						return rangeFactor(t, _min, _range);
					if(t>=_max)
						return rangeFactor(t, _max, _range);
						
					return 0.0;
				}
			}

			void main( void ) {
				float heightMap = vColor.x;
				vec4 tex1 = texture2D( texture1, vUv )*rangeFactor(heightMap, 0.0, 1.0);
				vec4 tex2 = texture2D( texture2, vUv )*rangeFactor(heightMap, 1.0, 1.0);
				//vec4 tex3 = texture2D( texture3, vUv )*areaRangeFactor(heightMap, 0.66*length, 1.0*length, range);
				vec4 tex4 = texture2D( texture4, vUv );

				float delta = abs(vColor.y);
				vec4 color = tex4*delta+(tex1+tex2);
				
				gl_FragColor = color*fogIntensity;
			}
		</script>

		<script id="vertexShader" type="x-shader/x-vertex">
			#define lightDir vec4(1.0,0.0,0.0,0.0)
			varying vec2 vUv;
			varying vec3 vColor;
			varying float fogIntensity;
			varying float reflection;
			uniform vec3 cameraPos;
			uniform float time;

			vec3 mod289(vec3 x) {
			  return x - floor(x * (1.0 / 289.0)) * 289.0;
			}

			vec4 mod289(vec4 x) {
			  return x - floor(x * (1.0 / 289.0)) * 289.0;
			}

			vec4 permute(vec4 x) {
			     return mod289(((x*34.0)+1.0)*x);
			}

			vec4 taylorInvSqrt(vec4 r)
			{
			  return 1.79284291400159 - 0.85373472095314 * r;
			}

			float snoise(vec3 v)
			  { 
			  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
			  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

			// First corner
			  vec3 i  = floor(v + dot(v, C.yyy) );
			  vec3 x0 =   v - i + dot(i, C.xxx) ;

			// Other corners
			  vec3 g = step(x0.yzx, x0.xyz);
			  vec3 l = 1.0 - g;
			  vec3 i1 = min( g.xyz, l.zxy );
			  vec3 i2 = max( g.xyz, l.zxy );

			  //   x0 = x0 - 0.0 + 0.0 * C.xxx;
			  //   x1 = x0 - i1  + 1.0 * C.xxx;
			  //   x2 = x0 - i2  + 2.0 * C.xxx;
			  //   x3 = x0 - 1.0 + 3.0 * C.xxx;
			  vec3 x1 = x0 - i1 + C.xxx;
			  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
			  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y

			// Permutations
			  i = mod289(i); 
			  vec4 p = permute( permute( permute( 
			             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
			           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
			           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

			// Gradients: 7x7 points over a square, mapped onto an octahedron.
			// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
			  float n_ = 0.142857142857; // 1.0/7.0
			  vec3  ns = n_ * D.wyz - D.xzx;

			  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)

			  vec4 x_ = floor(j * ns.z);
			  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

			  vec4 x = x_ *ns.x + ns.yyyy;
			  vec4 y = y_ *ns.x + ns.yyyy;
			  vec4 h = 1.0 - abs(x) - abs(y);

			  vec4 b0 = vec4( x.xy, y.xy );
			  vec4 b1 = vec4( x.zw, y.zw );

			  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;
			  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;
			  vec4 s0 = floor(b0)*2.0 + 1.0;
			  vec4 s1 = floor(b1)*2.0 + 1.0;
			  vec4 sh = -step(h, vec4(0.0));

			  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
			  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

			  vec3 p0 = vec3(a0.xy,h.x);
			  vec3 p1 = vec3(a0.zw,h.y);
			  vec3 p2 = vec3(a1.xy,h.z);
			  vec3 p3 = vec3(a1.zw,h.w);

			//Normalise gradients
			  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
			  p0 *= norm.x;
			  p1 *= norm.y;
			  p2 *= norm.z;
			  p3 *= norm.w;

			  // Mix final noise value
			  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
			  m = m * m;
			  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), 
			                                dot(p2,x2), dot(p3,x3) ) );
		  	}

			void main()
			{
				vUv = uv*1.0;
				vColor = color;
				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				vec3 worldPos = (modelMatrix*vec4( position, 1.0 )).xyz;
				fogIntensity = 1.0-pow(distance(cameraPos, worldPos)/750.0, 5.0);

				worldPos += vec3(1.0, 0.0, 0.0)*snoise(worldPos*0.01)+time*vec3(0.0, 0.05, 0.0)+sin(time/10.0)*vec3(1, 0.0, 0.0);

				float noiseTime = snoise(time*vec3(1.0, 0.0, 0.0));
				float noise0 = snoise(worldPos*0.1);
				float noise1 = snoise(worldPos*0.01);
				float noise2 = snoise(worldPos*0.001);
				float noise = ((noise0+noise1)*noise2)*10.0;

				vColor.x = 1.0+noise;
				vColor.y = noise0;
				vColor.z = 1.0-noise2;

				
				reflection = vColor.y;
				
				gl_Position = projectionMatrix * (mvPosition + vec4(0.0,1.0+noise2+1.0*noise,0.0,1.0)*10.0);
			}
		</script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;

			var clock = new THREE.Clock();

			var camera, scene, renderer, composer, controls;

			var worldWidth = 256, worldDepth = 256,
			worldHalfWidth = worldWidth / 2, worldHalfDepth = worldDepth / 2;

			var uniforms, material;

			var mouseX = 0, mouseY = 0,
			lat = 0, lon = 0, phy = 0, theta = 0;

			var width = window.innerWidth || 2;
			var height = window.innerHeight || 2;

			var windowHalfX = width / 2;
			var windowHalfY = height / 2;

			var ready = false;
			var blocsMap = {}
			var lastPosId = "";

			var timer = 0;
			
			init();
			animate();

			function init() {

				container = document.getElementById( 'container' );

				document.getElementById('reset').addEventListener("click", function(){
					timer = Math.random()*10000;
				});

				camera = new THREE.PerspectiveCamera( 45, windowHalfX / windowHalfY, 1, 30000 );
				camera.position.z = -500;

				controls = new THREE.FirstPersonControls( camera );
				controls.movementSpeed = 100;
				controls.lookSpeed = 0.1;

				scene = new THREE.Scene();
				scene.fog = new THREE.FogExp2( 0xefd1b5, 0.0025 );

				noise.seed(Math.random());

				var textureLoader0 = new THREE.TextureLoader();
				textureLoader0.load("textures/grass.jpg", function(tex0){
				
					var textureLoader = new THREE.TextureLoader();
					textureLoader.load("textures/dirt.jpg", function(tex){

						var textureLoader1 = new THREE.TextureLoader();
						textureLoader1.load("textures/rock.jpg", function(tex1){
						
							uniforms = {
								time: { type: "f", value: 0.0 },

								cameraPos: { type:"3f", value:[0,0,0]},

								texture1: { type: "t", value: tex1 },
								texture2: { type: "t", value: tex },
								texture3: { type: "t", value: tex  },
								texture4: { type: "t", value: tex0 }
							};

							uniforms.texture1.value.wrapS = uniforms.texture1.value.wrapT = THREE.RepeatWrapping;
							uniforms.texture2.value.wrapS = uniforms.texture2.value.wrapT = THREE.RepeatWrapping;
							uniforms.texture3.value.wrapS = uniforms.texture3.value.wrapT = THREE.RepeatWrapping;
							uniforms.texture4.value.wrapS = uniforms.texture4.value.wrapT = THREE.RepeatWrapping;

							material = new THREE.ShaderMaterial( {
									vertexColors: THREE.VertexColors,
									uniforms: uniforms,
									vertexShader: document.getElementById( 'vertexShader' ).textContent,
									fragmentShader: document.getElementById( 'fragmentShader' ).textContent

							} );


							renderer = new THREE.WebGLRenderer( { antialias: true } );
							renderer.setClearColor( 0x000000 );
							renderer.setPixelRatio( window.devicePixelRatio );
							renderer.setSize( window.innerWidth, window.innerHeight );
							container.appendChild( renderer.domElement );
							
							
							onWindowResize();

							window.addEventListener( 'resize', onWindowResize, false );

							ready = true;

						});
					});
				});
			}

			function onWindowResize( event ) {

				renderer.setSize( window.innerWidth, window.innerHeight );

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				controls.handleResize();

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();

			}
			
			function render() {
					
				controls.update( clock.getDelta() );
				
				timer += 0.5;

				//uniforms.time.value = timer;
				//mesh.rotation.y += 0.0125 * delta;
				//mesh.rotation.x += 0.05 * delta;

				updateBlocs();

				renderer.render( scene, camera );	
			}

			function updateBlocs()
			{
					if(!ready)
					{
						console.log("loading assets...");
						return;
					}	

					var step = 50;
					var generationRange = 15;

					var camPosId = getId(camera.position, step);

					for(var x=-generationRange; x<=generationRange; x++)
					{
						for(var y=-generationRange; y<=generationRange; y++)
						{
							var flatPos = flatten(new THREE.Vector3(x*step, 0, y*step).add(camera.position), step);
							flatPos.y = 0;
							var posId = getId(flatPos, step)
							if(!blocsMap[posId])
							{
								blocsMap[posId] = generateBloc(flatPos);
								break;
							}
						}		
					}

					clearBlocs();
			}

			function clearBlocs()
			{
				var destroyRange = 1000;
				for(var objectsID in blocsMap)
				{
					var groundCamera = new THREE.Vector3(camera.position.x, camera.position.y, camera.position.z);
					groundCamera.y = 0;

					var distance = blocsMap[objectsID].position.distanceTo(groundCamera);
					if(distance>destroyRange)
					{
						scene.remove( blocsMap[objectsID] );
						delete blocsMap[objectsID];
					}
					else
					{
						blocsMap[objectsID].material.uniforms['time'].value = timer;
						blocsMap[objectsID].material.uniforms['cameraPos'].value = [camera.position.x, camera.position.y, camera.position.z];
					}
				}
			}

			function generateBloc(position)
			{
					var geometry = new THREE.PlaneGeometry( 50, 50, 10, 10);
					geometry.rotateX(  - Math.PI / 2 );

					/*var faceIndices = [ 'a', 'b', 'c' ];

					for ( var f in  geometry.faces) {

						geometry.faces[f].normal =  new THREE.Vector3( 0, 1, 0 );

						for(var strI in faceIndices)	{
							var i = geometry.faces[f][faceIndices[strI]];
							var noiseV = getNoise((geometry.vertices[i].x+position.x)/100, (geometry.vertices[i].y+position.y)/100, (geometry.vertices[i].z+position.z)/100);
							var noiseWithOffset = getNoise((geometry.vertices[i].x+position.x+10)/100, (geometry.vertices[i].y+position.y)/100, (geometry.vertices[i].z+position.z)/100);
							
							var randomness = noise.simplex3((geometry.vertices[i].x+position.x)/10, (geometry.vertices[i].y+position.y)/10, (geometry.vertices[i].z+position.z)/10)*noiseV;
							var randomness2 = getLowScaleNoise((geometry.vertices[i].x+position.x)/100, (geometry.vertices[i].y+position.y)/100, (geometry.vertices[i].z+position.z)/100);
							
							var delta = Math.pow(Math.min(1, Math.abs(noiseWithOffset - noiseV)*100), 2);
							//geometry.vertices[i].x *= 1+noiseV/100;
							geometry.vertices[i].y = noiseV*200;
							//geometry.vertices[i].z *= 1+noiseV/100;
							geometry.faces[f].vertexColors[0] = new THREE.Color(Math.abs(noiseV), randomness, randomness2);
							geometry.faces[f].vertexColors[1] = new THREE.Color(Math.abs(noiseV), randomness, randomness2);
							geometry.faces[f].vertexColors[2] = new THREE.Color(Math.abs(noiseV), randomness, randomness2);
						}
					}*/

					var mesh = new THREE.Mesh( geometry, material );
					mesh.position.x = position.x;
					mesh.position.y = position.y;
					mesh.position.z = position.z;
					
					scene.add( mesh );

					return mesh;
			}

			function getNoise(x,y,z)
			{
				return noise.simplex3(x/5, y/5, z/5)/2.5;
			}

			function getLowScaleNoise(x,y,z)
			{
				return noise.simplex3(x/5, y/5, z/5);
			}

			function getId(vec, step)
			{
				return Math.floor(vec.x/step)*step+" "+Math.floor(vec.y/step)*step+" "+Math.floor(vec.z/step)*step;
			}

			function flatten(vec, step)
			{
				return new THREE.Vector3(Math.floor(vec.x/step)*step, Math.floor(vec.y/step)*step, Math.floor(vec.z/step)*step);
			}
		</script>

	</body>
</html>
